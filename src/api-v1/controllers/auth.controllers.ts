import {Request, Response} from 'express'
import bcrypt from 'bcrypt'
import {v4 as uid} from 'uuid'
import { User, UserRoles } from '../models/auth.models'
import { changePasswordSchema, emailOrSchema, emailLoginSchema, registerSchema, updateUserSchema, userNameOrSchema, usernameLoginSchema, roleSchema } from '../validators/auth.validators'
import { DbHelper } from '../helpers/database.helpers'


// instantiate the database helpers
const db = new DbHelper()

export async function registerUser (request:Request, response:Response){
    /*
     * This function aims to register new users into the system
     * the user id is auto-generated by uuid() module for maximum security
     * the admin role is added fist by default, other roles are selected by the user 
     * user input is validated and checked for errors using Joi before adding to the db
     * if no error present, using database helpers, user is added to the system
     * if an error is present the user will not be added to the database
     * a confirmation reponse is presented accordingly 
     */

    const id=uid()
    // const role = UserRoles.Admin
    const {firstName, lastName,userName,email,contactNumber,password,role} = request.body
    const {error} = registerSchema.validate(request.body)
    try {
        if(error){
            // return response.status(400).send(error.details[0].message)
            return response.status(400).send(error.message)
        } else {
            const hashedPassword = await bcrypt.hash(password,9)
            await db.exec('addUser', {
                id,
                firstName,
                lastName,
                userName,
                email,
                contactNumber,
                password:hashedPassword,
                role
            })
            return response.status(200).send({message:'Congratulations! You have successfully created a new account'})
        }
    } catch(error){
        return response.status(500).send(error)
    }
}

export async function loginUser(request:Request, response:Response){
	/*
     * this function aims to login existing users into the system
     * it requires the username or email and the respective users password
     * if exists, user is logged in
     * otherwise, a response is sent to the user to create a new account
     */

    const {emailOrUserName, password} = request.body
    const emailRegex = /^[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,}$/

    try {
        // if emailOrUserName pattern matches an email
        if (emailRegex.test(emailOrUserName)){
            const {error} = emailLoginSchema.validate(request.body)
            if (error) {
                return response.status(400).send(error.message)
            } else {
                const user = (await db.exec('getUserByEmail',
                    {email:emailOrUserName})).recordset as Array<User>
                
                const isValidUser = await bcrypt.compare(password,user[0].password)
                if (isValidUser){
                    return response.status(200).send({message:`Nice to see you again ${user[0].userName}!`})
                } else {
                    return response.status(400).send({message:'Oops! Seems like you entered an invalid password. Try again?'})
                }
            }
        // else if email regex doesnt match pattern i.e is a username
        } else if (!emailRegex.test(emailOrUserName)){
            const {error} = usernameLoginSchema.validate(request.body)
            if (error) {
                return response.status(400).send(error.message)
            } else {
                const user = (await db.exec('getUserByUserName',
                    {userName:emailOrUserName})).recordset as Array<User>

                const isValidUser = await bcrypt.compare(password, user[0].password)
                if (isValidUser){
                    return response.status(200).send({message:`Nice to see you again ${user[0].userName}!`})
                } else {
                    return response.status(400).send({message:'Oops! Seems like you entered an incorrect password. Try again?'})
                }
            }
        }

    } catch(error){
        return response.status(500).send({message:'Oh no! It seems like the email/username you entered does not exist. Try again?'})
    }

}


// forgot password ->before login in to acc
export async function forgotPassword(request:Request, response:Response){
    /*
     * function to change user pasword
     * located on login page. Click on link and redirected to a new page
     * where user will input either an email or username
     * if present in db, theyre sent to a new page
     * they enter and confirm the new password
     */

   const {emailOrUserName} = request.body
   const emailRegex = /^[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,}$/

   try {
        // if input matches email regex
        if (emailRegex.test(emailOrUserName)){
            const {error} = emailOrSchema.validate(request.body)
            if (error) {
                return response.status(400).send(error.message)
            } else {
                const user = (await db.exec('getUserByEmail',{
                    email:emailOrUserName
                })).recordset as Array<User>

                if (user){
                    await db.exec('forgotPassword',{
                        id:user[0].id
                    })
                    return response.status(200).send({message:`Hey ${user[0].userName}! We have sent an email to your account ${user[0].email}. Click on the link contained to change your password.`})
                } else {
                    return response.status(400).send({message:'Oops! It looks like there is no existing user with that email. Try again?'})
                }
            }

        } else if (!emailRegex.test(emailOrUserName)){
            // if input doesnt not match email
            const {error} = userNameOrSchema.validate(request.body)
            if (error){
                return response.status(400).send(error.message)
            } else {
                const user = (await db.exec('getUserByUserName',{
                    userName:emailOrUserName
                })).recordset as Array<User>

                if (user){
                    await db.exec('forgotPassword',{
                        id:user[0].id   //need backgroung process to return values to 0
                    })
                    return response.status(400).send({message:`Hey ${user[0].userName}! We have sent an email to your account ${user[0].email}. Click on the link contained to change your password.`})
                } else {
                    return response.status(400).send({message:'Oops! Looks like there is no existing user with that username. Try again?'})
                }
            }
        }

    } catch (error){
        return response.status(500).send({message:'Oh no! Looks like the email/username you entered do not exist. Create an account instead?'})
    }
}

// change password ->within the app 
export async function changePassword(request:Request<{id:string}>, response:Response){
    /*
     * for changing passwords within the application
     * also where the forgot password redirects you to
     * you enter and confirm the new password and it is updated on the db 
     */

    const id = request.params.id
    const {newPassword, confirmNewPassword} = request.body
    const {error} = changePasswordSchema.validate(request.body)
    try {
        if (error){
            return response.status(400).send(error.message)
        } else {
            const hashedPassword = await bcrypt.hash(confirmNewPassword,9)
            
            const user = (await db.exec('getUserById',{
                id
            })).recordset as Array<User>
    
            await db.exec('changePassword', {
                id,
                password:hashedPassword
            })
            return response.status(200).send({message:`Congratulations ${user[0].userName}. You have successfully changed your password. Login in again to continue activity.`})
        }
    } catch(error) {
        return response.status(500).send({message:'Oh no! It looks like you do not have an account. Create one instead?'})
    }
}

// update user info
export async function updateUser(request:Request<{id:string}>, response:Response){
    /*
     * This function will update the users account details 
     * You cannot update the role or password via this 
     */

    const id = request.params.id
    const {firstName,lastName,userName,email,contactNumber} = request.body
    const {error} = updateUserSchema.validate(request.body)

    try{
        if(error){
            return response.status(400).send(error.message)
        } else {
            const user = (await db.exec('getUserById', {
                id
            })).recordset as Array<User>

            await db.exec('updateUser',{
                id,
                firstName,
                lastName,
                userName,
                email,
                contactNumber
            })

            return response.status(200).send({message:`Congratulations ${user[0].userName}! You're details have been updated successfully.`})
        }
    } catch(error) {
        return response.status(500).send({message:'Oh no! It looks like you do not have an account. Create one instead?'})
    }
}

// delete user account
export async function deleteUser(request:Request<{id:string}>, response:Response){
    /*
     * This function will SOFT delete the user's account
     * It requires only an id 
     * MUST use recordset[0], else it will return an empty array that still evaluates
     * to true. such that even a deleted acc can still be deleted infinitely
     */

    const id = request.params.id
    try {
        const user = (await db.exec('getUserById', {
            id
        })).recordset[0] as User

        if (user) {
            await db.exec('deleteUser', {
                id
            })
            return response.status(200).send({message:`You have successfully deleted your account. Goodbye!`})
        } else {
            return response.status(400).send({message:'Oh no! It looks like you do not have an account. Create one instead?'})
        }
    } catch(error){
        return response.status(500).send(error)
    }
}

// ADMIN ROLES. WILL NEED TOKENS TO ACCESS
// get users 
export async function getUsers(request:Request, response:Response){
    /*
     * This will return all the users in the database 
     * The stored procedure has been modified appropriately to prevent seeing 
     * anyone with their roleset to `admin`
     */
    try{
        const users = (await db.get('getUsers')).recordset as Array<User>
        if(users){
            return response.status(200).send(users)
        } else {
            return response.status(400).send({message:'Oh no! It looks like there are no users in your database.'})
        }

    } catch(error){
        return response.status(500).send(error)
    }
}

// get user by id
export async function getUserById(request:Request<{id:string}>, response:Response){
    /*
     * this return data for one specific user 
     * their id needs to be passed in the request parameters
     * if no user of the id exists, approriate error messages are returned
     */

    const id = request.params.id
    try {
        const user = (await db.exec('getUserById', {
            id 
        })).recordset[0] as User

        if (user){
            return response.status(200).send(user)
        } else {
            return response.status(400).send({message:'Oh no! It looks like that user does not exist. Try again?'})
        }
    } catch(error) {
        return response.status(500).send(error)
    }
}

// get user by email/username
export async function getUserByEmailOrUserName(request:Request, response:Response){
    /*
     * will fetch user details using either their email or username 
     * email will mostly be utilized by the admin
     * the username by normal users to search for people they know
     */

    const {emailOrUserName} = request.body
    const emailRegex = /^[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,}$/

    try {
        if (emailRegex.test(emailOrUserName)){
            const {error} = emailOrSchema.validate(request.body)
            if (error){
                return response.status(400).send(error.message)
            } else {
                const user = (await db.exec('getUserByEmail', {
                    email:emailOrUserName
                })).recordset[0] as User

                if (user){
                    return response.status(200).send(user)
                } else {
                    return response.status(400).send({message:'Oops! It looks like there is no user with that username/email. Try again?'})
                }
            }
        } else if (!emailRegex.test(emailOrUserName)){
            const {error} = userNameOrSchema.validate(request.body)
            if (error){
                return response.status(400).send(error.message)
            } else {
                const user = (await db.exec('getUserByUserName',{
                    userName:emailOrUserName
                })).recordset[0] as User

                if (user){
                    return response.status(200).send(user)
                } else {
                    return response.status(400).send({message:'Oops! It looks like there is no user with that username/email. Try again?'})
                }
            }
        } 
    } catch(error){
        return response.status(500).send(error)
    }
}

// get users by roles
export async function getUserByRole(request:Request, response:Response){
    /*
     * will return users assigned a specific role within the app  
     */

    const {role} = request.body
    const {error} = roleSchema.validate(request.body)
    try {
        if (error){
            return response.status(400).send(error.message)
        } else {
            const users = (await db.exec('getUserByRole', {
                role
            })).recordset as Array<User>

            if (users.length !== 0){
                return response.status(200).send(users)
            } else {
                return response.status(400).send({message:'Oh no! It seems that there are no users with that role. Try again?'})
            }
        }
    } catch(error){
        return response.status(500).send(error)
    }
}